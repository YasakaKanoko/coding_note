# 区块链技术与应用

## 密码学原理

**比特币**：被称为加密货币 ( crypto-currency ) ，本身并不加密，在区块链中所有交易信息公开 ( 如：交易地址、转账金额等 )

主要应用**密码学的两个功能**：一个是**哈希**，另一个是**签名**

**哈希**：

- **哈希函数**：cryptographic hash function

  - **哈希碰撞**：collision resistance 

    假设有两个输入 `(x, y)` 且 `x ≠ y`，通过哈希函数计算得出哈希值相同，即 `H(x) = H(y)`，那么就称为「**哈希碰撞**」

    不同输入可能映射哈希表中的同一位置，所以，哈希碰撞是不可避免的，因为输入空间是远大于输出空间的

    假设哈希值是 `256` 位，那么对应的哈希值有 `2^256` 个，而输入空间可以有无限个

  - **暴力破解**：由于碰撞是客观存在的，没有任何高效的方式人为制造哈希碰撞，即给定一个 `x`，没有任何合适的方法找到一个 `y` 与 `x` 恰好相等，使得 `H(x) = H(y)` 成立；通过 `brute-force` 遍历所有输入的可能性，实际中是行不通的

  - **信息摘要**：message digest

    在区块链中，`message` 通常是记录、传输或处理的数据，如：发送者、接收者和交易金额等

    `digest`：摘要。通过哈希函数对 `message` 进行处理后得到的定长字符串，是 `message` 的唯一标识。起到验证和确认 `message` 完整性的作用。任何对 `message` 的修改都会生成不同的 `digest`，确保数据安全性、不可篡改性

    当本地上传一个 `m` 后，计算得出哈希值为 `H(m)`，其他人想篡改内容，是不可能找到一个 `m'` 得出的 `H(m')` 恰好与原来的 `H(m)` 相等，因此，无法做到篡改内容同时又通过检测

    当从服务器下载 `m` 时，计算得出 `H(m)` 与本地的哈希值比较结果相同，说明上传的文件未被篡改

  - **MD5**：哈希函数过去被认为是 collision resistance ，后来被人为实现哈希碰撞的方法

- **hiding**：哈希函数的计算过程是单向的，是不可逆的

  给定一个输入 `x`，计算得出哈希值 `H(x)`，无法通过 `H(x)` 反推出 `x` 的内容

  `hiding` 实现的前提：输入空间足够大、分布空间足够均匀 且各种取值的可能性差不多，否则当值集中某一个区段内，还是很容易被破解

- **数字承诺**：digital commitment / digital equivalent of a sealed envelope

  sealed envelope：

  现实意义说法，即股市里有一个专家，他预测这支股票的涨跌情况；

  第一种情况，他预测涨了，而他又碰巧猜对了，第二天，大家发现股票确实涨了；

  第二种情况，他预测涨了，而公众听了他的建议争先恐后的购买，导致股票涨了；

  第三种情况，他预测涨了，但有人想砸他的场子，大家都不买，这支股票原先按照预期应该涨，但是没人买就跌了

  总之，股票的最终结果会受他的预测结果影响，为了不受他预测结果的影响，就不能公开预测结果，那么就无法确保预测结果是否被篡改过；那么，为了结果即不受他影响，又能确保他结果的准确性，我们可以将他的预测结果封装到一个**信封**「sealed envelope」中，并将信封交给一个第三方公证机构，确保在第二天收盘时公开验证预测结果的准确性

  从区块链的角度实现 digital equivalent of a sealed envelope，就是把预测结果作为输入 `x` ，通过哈希函数计算得出哈希值 `H(x)`，将预测结果公布，由于 collision resistance 的性质，`x` 是不可篡改的；且由于 hiding 的性质，`x` 是不可逆的

  **注意**：上述例子中，hiding 性质的前提是，输入空间足够大且分布均匀；如果分布是均匀的，但输入空间不是足够大情况，如：股票一共只有几千支，常用方法是在原来的输入后拼接一个随机数 ( `x||nonce` )，再一起取哈希 ( `H(x||nonce)` )，保证输入是随机的

- **puzzle friendly**：从 BTC 角度，除了 hiding 和 digital equivalent of a sealed envelope 两个性质还存在一个 puzzle friendly ，即 `H(x)` 具有不可预测性

  假设一个哈希值为 256 位，它的 target space 为前 `k` 位为 `0` ，我们只能通过一个一个不断尝试找到符合要求的哈希值，这个过程没有捷径

  **挖矿**：就是寻找一个 nonce 和其他信息组合的一个输入求得的哈希值小于等于一个阈值 ( `H(BlockHeader) <= target` )，它的 target space 只有在 header 处才是一个合法的哈希值，因此，整个过程没有捷径；这个过程称为**工作量证明**「proof of work」

  **特性**：Difficult to Solve, but easy to verify. 他人对于 POW 只需解出一次哈希即可

  > BTC 中的哈希函数为 SHA-256 ( Secure Hash Algorithm )，符合上述三个性质

**签名**：

- 账户管理：去中心化；仅需一个公私钥对 `( public key, private key )`

  源于 **非对称加密体系**「asymmetric encryption algorithm 」

  **对称加密体系** 「symmetric encryption algorithm」：通讯双方事先准备一个秘钥 「encryption key」，信息加密后通过该秘钥传输，通过解密秘钥获取内容，加密和解密使用同一个秘钥，整个过程都需建立在安全的渠道分发秘钥给通讯双方，否则会被窃听

  **非对称加密体系**，就是一组公私钥对；加密用公钥，解密用私钥。

  假设 A 向 B 传输消息时，只需使用 B 的公钥对消息加密，B 收到消息只能使用 B 本地的私钥进行解密；公钥相当于卡号，私钥相当于密码；

  **应用**：**数字签名**；

  当 A 向 B 发起交易，用 A 的私钥对交易进行签名，交易会发布到区块链上，别人可以通过 A 的公钥去验证交易的真实性；

  理论上，两个人生成同一个公私钥对是可行的，实际中是不可行的，概率微乎其微；不被破解的前提在于需要一个好的随机源「 a good source of  randomness 」，这个随机源不仅在于生成公私钥对时需要好的随机源，而且在每一次交易签名时，也需要一个好的随机源，否则会被破解

## 数据结构

哈希指针「 Hash Pointers 」