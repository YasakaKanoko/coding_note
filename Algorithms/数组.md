**线性表**：数组、链表、栈、队列

**非线性**：树、图、堆

# Array

编号从 0 开始，连续的存储结构，存储同一类型的数据

```javascript
let arr = [1, 2, 3, 4, 5];
```

**优点**：

- **随机访问**：通过下标随机访问任意位置上的数据

**缺点**：对数据的删除和插入不友好

**查找**：根据下标随机访问的时间复杂度 `O(1)`

**插入或删除**：时间复杂度 `O(n)`

数组模拟 **栈** 或 **队列**

- **栈**：后进先出

  ```javascript
  let stack = [1, 2, 3, 4];
  
  // 进栈
  stack.push(5);
  // 出栈
  stack.pop();
  ```

- **队列**：先进后出

  ```javascript
  let queue = [1, 2, 3, 4];
  
  // 入队
  queue.push(5);
  // 出队
  queue.shift();
  ```

  

# Chrome V8

`JS Array` 继承自 `JSObject`，数组是一个特殊的对象，内部以 key-value 形式存储数据，可以存放不同类型的值

**存储：**

- `fast`：存储结构是 `FixedArray`，数组长度：`length <= elements.length()`，`push` 和 `pop` 会伴随着动态扩容或减容
- `slow`：存储结构是 `HashTable` ( 哈希表 )，并且数组下标作为 `key`

`fast` 模式下数组称为 `FastElements`，`slow` 模式下叫做 `SlowElements`

1. **快数组**

   `FixedArray` 是 V8 实现的一个类似数组的类，表示一段连续的内存，可以直接使用索引进行定位。新创建的空数组默认是快数组。当数组满时 ( 数组长度在内存中申请的容量最大值 )，继续使用 `push`，`JSArray` 会进行动态扩容，便于存储更多的元素。

2. **慢数组**

   慢数组以哈希表的形式存储在内存空间中，不需要连续开辟内存空间，需要额外维护一个哈希表，与快数组相比，性能相对较差

> **什么时候会从 `fast` 转为 `slow`？**
>
> - 当索引值 `index` 比当前容量 `captivity` 差值大于等于 `1024` 时 ( `index - captivity >= 1024` )
> - 当数组的新容量是扩容后的 3 倍

```javascript
// 给arr增加一个2000的索引，arr会转为慢数组，节省内存空间
let arr = [1, 2, 3];
arr[2000] = 10;
```

> **什么时候从 `slow` 转 `fast` ?**
>
> 当慢数组的元素可存放在快数组中，且长度在 `Smi` 之间，至少可以节省 50% 的空间，则会转为快数组
>
> `Smi`：小整数的最大值

Fast Elements **动态扩容与减容**

**扩容：**

1. 默认空数组初始化大小为 `4`

2. 当执行 `push` 操作时，一旦发现内存不足，`new_capacity = old_capacity / 2 + old_capacity + 16`

   即老容量的 1.5 倍加上 16

   步骤：

   - `push` 操作，发现内存不足
   - 申请 `new_capacity = old_capacity / 2 + old_capacity + 16` 长度空间
   - 将数组拷贝到新数组中
   - 新元素放在 `length` 位置
   - 数组 `length + 1`
   - 返回 `length`

**减容：** `pop` 基于 C++ 实现。当执行 `pop` 后，如果数组容量大于等于 `length` 的 2 倍，使用 `RightTrimFixedArray` 函数，计算出需要释放空间的大小，做好标记，等待 `GC` 回收；如果数组容量小于 `length` 的 2 倍，则用 `holes` 对象填充

步骤：

- `pop` 操作时，获取数组 `length`
- 获取 `length - 1` 的元素 ( 要删除的元素 )
- 数组 `length - 1`
- 判断数组总容量是否大于等于 `length - 1` 的 2 倍
- 是，使用 `RightTrimFixedArray` 函数，计算要释放的空间，并做好标记，等待 `GC` 回收
- 否，用 `holes` 对象填充
- 返回要删除的元素

# 数组扁平化、去重、排序

> 已知：`var arr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];`
>
> 将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

```javascript
var arr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10];
// 扁平化
let flatArr = arr.flat(Infinity);
// 去重
let disArr = Array.from(new Set(flatArr));
// 排序
let result = disArr.sort((a, b) => a - b);
console.log(result);
```

