# 链表

链表，不同于数组，在内存中是不必连续的空间

- 内存空间中不连续
- 每个元素由一个存储元素本身的节点和一个指向下一元素的引用

**优点：**

- 空间不连续，灵活的内存动态管理
- 不必在创建时确定大小，大小可以无限延申
- 插入和删除时，时间复杂度可以达到 O(1)

**缺点：**

- 访问任意元素都需要从头开始
- 无法通过下标直接访问元素，需要从头开始一个一个访问，知道找到对应为止
- 很轻易到达下一节点，但回到前一节点很难

## 单向链表

单向链表，类似火车

`head` 指向第一个节点，链表的最后一个几点指向 `null`，当链表中一个节点都没有时，`head` 指向 `null`

```pseudocode
head / root -> [item1, next] -> [item2, next] -> [item3, next] -> null
```

### 单向链表类

```javascript
class LinkedList {
    // 初始链表长度为0
    length = 0;
    // 初始head为null, head指向第一个节点
    head = null;

    // 内部类Node
    Node = class {
        constructor(data, next) {
            this.data = (data === undefined ? 0 : data);
            this.next = (next === undefined ? null : next);
        }
    };
}
module.exports = LinkedList;
```

### 实现 `append(element)`

`append(element)`：链表尾部添加一个新的项

```javascript
// append(element): 向尾部添加元素
append(element) {
    // 1. 创建新节点
    const newNode = new this.Node(element);
    // 2. 判断: 如果链表长度为0, 只有head时, 直接追加新节点
    if (this.length === 0) {
        this.head = newNode;
    } else {
        // 当长度大于0时, 在最后的位置添加新的节点
        let currentNode = this.head;
        while (currentNode.next !== null) {
            currentNode = currentNode.next;
        }
        currentNode.next = newNode;
    }
    // 3. 追加节点后, 长度+1
    this.length++;
}
```

### 实现 `insert(position, data)`

`insert(position, element)`：向链表的特定位置插入一个新项

```javascript
// insert():在指定位置插入节点
insert(position, data) {
    // position: 插入节点的位置
    // position = 0: 插入后是第一个节点
    // 1. 对position进行越界判断, 不能小于0或大于链表长度
    if (position < 0 || position > this.length) return false;
    // 2. 创建新节点
    const newNode = new this.Node(data);
    // 3. 插入节点
    if (position === 0) {
        // position = 0时, next指向原来第一个节点
        // newNode -> [head, 1]
        newNode.next = this.head;
        this.head = newNode;
    } else {
        // 0 < position <= length
        // 初始化变量
        let currentNode = this.head; // 当前节点初始化为head
        let previousNode = null; // head的上一节点为null
        let currentIndex = 0; // head的index为0
        while (currentIndex < position) {
            previousNode = currentNode;
            currentNode = currentNode.next;
            currentIndex++;
        }
        previousNode.next = newNode;
        newNode.next = currentNode;
    }
    this.length++;
    return true;
}
```

### 实现 `getData(position)`

`getData(position)`：获取对应位置的元素

```javascript
// getData(position): 获取对应位置的元素
getData(position) {
    // 1. 越界判断
    if (position < 0 || position >= this.length) return null;
    // 2. 获取指定position的data
    let currentNode = this.head;
    let currentIndex = 0;

    while (currentIndex < position) {
        currentNode = currentNode.next;
        currentIndex++;
    }
    // 3. 返回data
    return currentNode.data;
}
```

### 实现 `indexOf(data)`

`indexOf(data)`：返回元素在链表中的索引，不存在该元素返回 `-1`

```javascript
// indexOf(data): 返回元素在链表中的索引，不存在该元素返回 -1
indexOf(data) {
    let currentNode = this.head;
    let currentIndex = 0;
    while (currentNode) {
        if (currentNode.data === data) {
            return currentIndex;
        }
        currentNode = currentNode.next;
        currentIndex++;
    }
    return -1;
}
```

### 实现 `update(position, data)`

`update(position, data)`：修改某个位置的元素

```javascript
// update(position, data): 修改某个位置的元素
update(position, data) {
    // 1. 越界判断
    if (position < 0 || position >= this.length) return false;

    // 2. 循环遍历, 找到指定position节点
    let currentNode = this.head;
    let currentIndex = 0;
    while (currentIndex < position) {
        currentNode = currentNode.next;
        currentIndex++;
    }
    // 3. 修改data
    currentNode.data = data;
    return currentNode;
}
```

### 实现 `removeAt(position)`

`removeAt(position)`：删除特定位置的元素

```javascript
// removeAt(position): 删除特定位置的元素
removeAt(position) {
    // 1. 越界判断
    if (position < 0 || position >= this.length) return null;
    // 2. position = 0时
    let currentNode = this.head;
    if (position === 0) {
        this.head = this.head.next;
    } else {
        // position > 0时, 通过遍历找到position, 赋值currentNode
        let previousNode = null;
        let currentIndex = 0;
        while (currentIndex < position) {
            previousNode = currentNode;
            currentNode = currentNode.next;
            currentIndex++;
        }
        // 上一节点的next指向当前节点的next, 就相当于删除了当前节点
        previousNode.next = currentNode.next;
    }
    // 3. 链表长度-1
    this.length--;
    return currentNode;
}
```

### 实现 `remove(data)`

`remove(data)`：删除指定 `data` 所在的节点。

```javascript
// remove(data): 删除指定 data 所在的节点。
remove(data) {
    this.removeAt(this.indexOf(data));
}
```

### 实现 `isEmpty()`

`isEmpty()`：判断链表是否为空

```javascript
// isEmpty(): 判断链表是否为空
isEmpty() {
    return this.length === 0;
}
```

### 实现 `size()`

`size()`：返回元素个数

```javascript
// size(): 获取链表长度
get size() {
    return this.length;
}
```

### 实现 `toString()`

`toString()`：遍历所有节点拼接字符串，直到 `null`，输出元素值

```javascript

// toString(): 遍历所有节点拼接字符串，直到 null，输出元素值
toString() {
    let currentNode = this.head;
    let result = '';
    while (currentNode) {
        result += currentNode.data + '->';
        currentNode = currentNode.next;
    }
    return result + 'null';
}
```

### 测试

```javascript
const LinkedList = require('./LinkedList');

const linkedList = new LinkedList();
// 测试 append 方法
linkedList.append("A");
linkedList.append("B");
linkedList.append("C");
console.log(linkedList.toString()); // A->B->C->null
// 测试 insert 方法
linkedList.insert(0, "123");
linkedList.insert(2, "456");
console.log(linkedList.toString()); // 123->A->456->B->C->null

// 测试 getData 方法
console.log(linkedList.getData(0)); // 123
console.log(linkedList.getData(1)); // A

// 测试 indexOf 方法
console.log(linkedList.indexOf("A")); // 1
console.log(linkedList.indexOf("ABC")); // -1

// 测试 update 方法
linkedList.update(0, "12345");
console.log(linkedList.toString()); // 12345->A->456->B->C->null
linkedList.update(1, "54321");
console.log(linkedList.toString()); // 12345->54321->456->B->C->null

// 测试 removeAt 方法
linkedList.removeAt(3);
console.log(linkedList.toString()); // 12345->54321->456->C->null

// 测试 remove 方法
linkedList.remove("C");
console.log(linkedList.toString()); // 12345->54321->456->null

// 测试 isEmpty 方法
console.log(linkedList.isEmpty()); // false

// 测试 size 方法
console.log(linkedList.size); // 3
```

## 双向链表

**单向链表**

- 只能从头遍历到尾或从尾遍历到头
- 链表相连的过程是单向的，原理：上一个节点指向下一个节点的引用
- 缺点：可以轻松到达下一个节点，但很难回到上一个节点

**双向链表**

- 既可以从头到尾，也可以从尾到头
- 链表相连的过程是双向的，原理：既有一个节点向前连接的引用，也有一个向后连接的引用
- 缺点：
  1. 每次插入或删除时，都需要处理 4 个引用，而不是 2 个，实现起来很困难
  2. 相对于单向链表，内存空间占用更大

结构：

