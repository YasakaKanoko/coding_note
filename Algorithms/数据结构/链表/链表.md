# 链表

链表，不同于数组，在内存中是不必连续的空间

- 内存空间中不连续
- 每个元素由一个存储元素本身的节点和一个指向下一元素的引用

**优点：**

- 空间不连续，灵活的内存动态管理
- 不必在创建时确定大小，大小可以无限延申
- 插入和删除时，时间复杂度可以达到 O(1)

**缺点：**

- 访问任意元素都需要从头开始
- 无法通过下标直接访问元素，需要从头开始一个一个访问，知道找到对应为止
- 很轻易到达下一节点，但回到前一节点很难

## 单向链表

单向链表，类似火车

`head` 指向第一个节点，链表的最后一个几点指向 `null`，当链表中一个节点都没有时，`head` 指向 `null`

```pseudocode
head / root -> [item1, next] -> [item2, next] -> [item3, next] -> null
```

### 常见操作

- `append(element)`：链表尾部添加一个新的项
- `insert(position, element)`：向链表的特定位置插入一个新项
- `get(position)`：获取对应位置的元素
- `indexOf(element)`：返回元素在链表中的索引，不存在该元素返回 `-1`
- `update(position, element)`：修改某个位置的元素
- `removeAt(position)`：删除特定位置的元素
- `remove(element)`：删除一项
- `isEmpty()`：判断链表是否为空
- `size()`：返回元素个数
- `toString()`：输出元素值

```javascript
class LinkedList {
    // 初始链表长度为0
    length = 0;
    // 初始head为null, head指向第一个节点
    head = null;

    // 内部类Node
    Node = class {
        constructor(data, next) {
            this.data = (data === undefined ? 0 : data);
            this.next = (next === undefined ? null : next);
        }
    }
    
    // append(element): 向尾部添加元素
    append(element) {
        // 1. 创建新节点
        const newNode = new this.Node(element);
        // 2. 判断: 如果链表长度为0, 只有head时
        if (this.length === 0) {
            this.head = newNode;
        } else {
            // 当长度大于0时, 在最后的位置添加新的节点
            let currentNode = this.head;
            while (currentNode.next !== null) {
                currentNode = currentNode.next;
            }
            currentNode.next = newNode;
        }
        // 3. 追加节点后, 长度+1
        this.length++;
    }
    
    // toString(): 遍历所有节点拼接字符串,直到null
    toString() {
        let currentNode = this.head;
        let result = '';
        while (currentNode) {
            result += currentNode.data + '->';
            currentNode = currentNode.next;
        }
        return result + 'null';
    }
    
    // insert():在指定位置插入节点
    insert(position, data) {
        // position: 插入节点的位置
        // position = 0: 插入后是第一个节点
        // 1. 对position进行越界判断, 不能小于0或大于链表长度
        if (position < 0 || position > this.length) return false;
        // 2. 创建新节点
        const newNode = new this.Node(data);
        // 3. 插入节点
        if (position === 0) {
            // position = 0时, next指向原来第一个节点
            // newNode -> [head, 1]
            newNode.next = this.head;
            this.head = newNode;
        } else {
            // 0 < position <= length
            // 初始化变量
            let currentNode = this.head; // 当前节点初始化为head
            let previousNode = null; // head的上一节点为null
            let currentIndex = 0; // head的index为0
            while (currentIndex < position) {
                previousNode = currentNode;
                currentNode = currentNode.next;
                currentIndex++;
            }
            previousNode.next = newNode;
            newNode.next = currentNode;
        }
        this.length++;
        return true;
    }
    
    // getData(position)
    getData(position) {
        // 1. 越界判断
        if (position < 0 || position >= this.length) return null;
        // 2. 获取指定position的data
        let currentNode = this.head;
        let currentIndex = 0;
        while (currentIndex < position) {
            currentNode = currentNode.next;
            currentIndex++;
        }
        return currentNode.data;
    }
    
    indexOf(data) {
        let currentNode = this.head;
        let currentIndex = 0;
        while (currentNode) {
            if (currentNode.data === data) {
                return currentIndex;
            }
            currentNode = currentNode.next;
            currentIndex++;
        }
        return -1;
    }
    
    update(position, data) {
        // 1. 越界判断
        if (position < 0 || position >= this.length) return false;
        let currentNode = this.head;
        let currentIndex = 0;
        while (currentIndex < position) {
            currentNode = currentNode.next;
            currentIndex++;
        }
        currentNode.data = data;
        return currentNode;
    }
    
    removeAt(position) {
        if (position < 0 || position >= this.length) return null;
        let currentNode = this.head;
        if (position === 0) {
            this.head = this.head.next;
        } else {
            let previousNode = null;
            let currentIndex = 0;
            while (currentIndex < position) {
                previousNode = currentNode;
                currentNode = currentNode.next;
                currentIndex++;
            }
            previousNode.next = currentNode.next;
        }
        this.length--;
        return currentNode;
    }
    
    remove(data) {
        this.removeAt(this.indexOf(data));
    }
    
    isEmpty() {
        return this.length === 0;
    }
    
    get size() {
        return this.length;
    }
}
module.exports = LinkedList;
```

### 测试

```javascript
const LinkedList = require('./LinkedList');

const linkedList = new LinkedList();
// 测试 append 方法
linkedList.append("A");
linkedList.append("B");
linkedList.append("C");
console.log(linkedList.toString()); // A->B->C->null
// 测试 insert 方法
linkedList.insert(0, "123");
linkedList.insert(2, "456");
console.log(linkedList.toString()); // 123->A->456->B->C->null

// 测试 getData 方法
console.log(linkedList.getData(0)); // 123
console.log(linkedList.getData(1)); // A

// 测试 indexOf 方法
console.log(linkedList.indexOf("A")); // 1
console.log(linkedList.indexOf("ABC")); // -1

// 测试 update 方法
linkedList.update(0, "12345");
console.log(linkedList.toString()); // 12345->A->456->B->C->null
linkedList.update(1, "54321");
console.log(linkedList.toString()); // 12345->54321->456->B->C->null

// 测试 removeAt 方法
linkedList.removeAt(3);
console.log(linkedList.toString()); // 12345->54321->456->C->null

// 测试 remove 方法
linkedList.remove("C");
console.log(linkedList.toString()); // 12345->54321->456->null

// 测试 isEmpty 方法
console.log(linkedList.isEmpty()); // false

// 测试 size 方法
console.log(linkedList.size); // 3
```

## 双向链表

**单向链表**

- 只能从头遍历到尾或从尾遍历到头
- 链表相连的过程是单向的，原理：上一个节点指向下一个节点的引用
- 缺点：可以轻松到达下一个节点，但很难回到上一个节点

**双向链表**

- 既可以从头到尾，也可以从尾到头
- 链表相连的过程是双向的，原理：既有一个节点向前连接的引用，也有一个向后连接的引用
- 缺点：
  1. 每次插入或删除时，都需要处理 4 个引用，而不是 2 个，实现起来很困难
  2. 相对于单向链表，内存空间占用更大

结构：

