# Map

**哈希表 ( Hash Map )**，又称散列表，通过 `key` 和 `value` 之间的映射，实现高效查询。

即在 `O(1)` 复杂度内获取 `key` 对应的 `value`

|      | Array | ListNode | Map  |
| ---- | ----- | -------- | ---- |
| 查找 | O(n)  | O(n)     | O(1) |
| 添加 | O(1)  | O(1)     | O(1) |
| 删除 | O(n)  | O(n)     | O(1) |

```javascript
const map = new Map();

// 添加元素
map.set(1, 'S');
map.set(2, 'H');
map.set(3, 'I');
map.set(4, 'T');

// 查询
let name = map.get(1);

// 删除
map.delete(2);
```

## 遍历

1. 遍历键值对

   ```javascript
   for (const [k, v] of map.entries()) {
       console.info(k + '->' + v)
   }
   ```

2. 遍历键

   ```javascript
   for (const k of map.keys()) {
       console.info(k)
   }
   ```

3. 遍历值

   ```javascript
   for (const v of map.values()) {
       console.info(v)
   }
   ```

   

# array_hash_map

假设数组的每个空位称为桶 ( `bucket` )

每个桶可以存储一个键值对。查找就是找到 `key` 对应的 `bucket` ，从桶中获取对应的 `value` 

> 如何基于 `key` 定位对应的桶？
>
> **哈希函数 ( Hash Function )**：将一个较大的输入空间映射到较小的输出空间
>
> 输入空间：`key`
>
> 输出空间：数组索引

1. 通过哈希算法 `hash()` 计算哈希值
2. 将哈希值对 桶数量 ( 数组长度 ) `capacity` 取模 ，获取到 `key` 对应的索引 `index`

`index = hash(key) % capacity`

## Hash Collision

**哈希冲突**：多个输入对应相同输出

`12836 % 100 = 36`

`20336 % 100 = 36`

**哈希扩容**：哈希容量 `n` 越大，多个 `key` 被分配到同一个 `bucket` 中的概率越低

哈希扩容需要将所有的键值迁移到新哈希表，非常耗时；由于哈希容量 `capacity` 改变，通过哈希函数重新计算键值对的存储位置

**负载因子** ( load factor )：当哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，触发哈希表扩容的条件。

> 在 Java 中，负载因子超过 0.75 时，系统自动扩容至原先的 2 倍

理论上，哈希冲突不可避免，

**解决方法**：哈希表扩容。简单粗暴，效率太低

哈希表的**结构改良**：链式地址、开放寻址

###  Separate Chaining

**链式地址 ( Separate Chaining )**：将单个元素转换为链表，将键值对作为链表节点，每个发生冲突的键值都存储在同一链表中。

- **查询**：输入 `key`，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 `key` 查找目标键值对
- **添加**：首先通过哈希函数访问链表头节点，然后将节点 ( 键值对 ) 添加到链表中
- **删除**：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除

**局限**：

- 占用空间大。包含节点指针，相比数组而言更耗费内存空间
- 效率低。需要线性遍历链表查询对应元素

> 当链表很长时，查询效率 `O(n)` 差。此时可以**将链表转为 " AVL 树 " 或 " 红黑树 "**，查询的时间复杂度被优化为 `O(logn)`

### Open Addressing

**开放寻址**：不引入额外数据结构，而是通过 " 多次探测 " 处理哈希冲突，探测主要包括**线性探测**、**平方探测** 和 **多次哈希**

1. **线性探测**

   - **插入**：通过哈希函数计算桶索引，若桶内已有元素，则从冲突位置处向后线性遍历 ( 步长通常为 1  )，直至找到空桶
   - **查找**：发现哈希冲突，使用相同步长向后进行线性遍历，直至找到对应元素，返回 `value`；如果遇到空桶，说明目标不在哈希表中，返回 `None`
   
   > 线性探测容易产生 **" 聚焦现象 "**：
   > - 数组中连续被占用的位置越长，发生哈希冲突的可能性越大，从而促使聚堆增长，恶性循环，导致增删改查效率劣化
   > - **不能在开放寻址的哈希表中直接删除元素**。删除元素会在数组中产生一个空桶 `None`。当查询元素时，线性探测到空桶直接返回，空桶之下的元素无法访问。

   **懒删除 ( Lazy Deletion )** 机制：**不直接从哈希表中移除元素，利用一个常量** `TOMBSTONE` **来标记这个桶**。在当前机制下，`None` 和 `TOMBSTONE` 都代表空桶，都可以放置键值对。线性探测到 `TOMBSTONE` 时，应该继续遍历，其下方仍可能还存在键值对。

   懒删除可能加速哈希表的性能退化。每次删除操作都会产生一个删除标记，随着 `TOMBSTONE` 的增加，探索时间也会增加。线性探测可能需要跳过多个 `TOMBSTONE` 才能找到目标元素

   线性探测中记录的首个 `TOMBSTONE` 的索引，并将目标元素与该 `TOMBSTONE` 交换位置。每次查询或添加元素时，元素会被移动至距离理想位置更近的桶，从而优化查询效率。

   为了充分利用哈希表的空间，将哈希表看做一个 " 环形数组 "，当越过数组尾部时，回到头部继续遍历。

2. **平方探测**

   平方探测与线性探测类似，是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单跳过一个固定的步长，而是 " 跳过探测次数的平方 "，如：1、4、9……

   优势：

   - 通过跳过探测次数的平方距离，缓解线性探测的聚焦效应
   - 平方探测会跳过更大的距离来寻找空位，有助于数据分布均匀

   但

   - 仍存在聚焦现象，某些位置比其他位置更容易占用
   - 随着平方的增长，平方探测不会探测整个哈希表，意味着表中仍有空桶，平方探测无法访问

3. **多次哈希**

   使用多个哈希函数进行探测

   - **插入**：若哈希函数 `f1(x)` 出现冲突，则尝试 `f2(x)`，以此类推，直到找到空位插入元素
   - **查找**：先在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已经尝试所有哈希函数，说明哈希表中不存在该元素，返回 `None`

   多次哈希不易产生聚集，但多个哈希会带来额外计算量

## 哈希算法

开放寻址还是链式地址，只能保证哈希表在发生冲突时正常工作，无法减少哈希冲突的发生

链式地址：

- 理想情况下，键值对分布均匀在各个桶中，达到最佳查询效率，时间复杂度 `O(1)`
- 最差情况下，键值对都存储在同一个桶中，时间复杂度 `O(n)`

哈希算法设计：

- **加法哈希**：对每个字符的 ASCII 码进行相加，将得到的和作为哈希值。
- **乘法哈希**：利用乘法的不相关性，每轮乘以一个常数，将各个字符的 ASCII 码累积到哈希值中。
- **异或哈希**：将输入数据的每个元素通过异或操作累积到一个哈希值中
- **旋转哈希**：将每个字符的 ASCII 码累积到一个哈希值中，每次累积之前都会对哈希值进行旋转操作。

```javascript
/* 加法哈希 */
function addHash(key) {
    let hash = 0;
    const MODULUS = 1000000007;
    for (const c of key) {
        hash = (hash + c.charCodeAt(0)) % MODULUS;
    }
    return hash;
}

/* 乘法哈希 */
function mulHash(key) {
    let hash = 0;

    const MODULUS = 1000000007;
    for (const c of key) {
        hash = (31 * hash + c.charCodeAt(0)) % MODULUS;
    }
    return hash;
}

/* 异或哈希 */
function xorHash(key) {
    let hash = 0;
    const MODULUS = 1000000007;
    for (const c of key) {
        hash ^= c.charCodeAt(0);
    }
    return hash & MODULUS;
}

/* 旋转哈希 */
function rotHash(key) {
    let hash = 0;
    const MODULUS = 1000000007;
    for (const c of key) {
        hash = ((hash << 4) ^ (hash >> 28) ^ c.charCodeAt(0)) % MODULUS;
    }
    return hash;
}
```

**注意**：每种哈希算法的最后一步都是对大质数 1000000007 取模，以确保哈希值在合适的范围内。

> 为什么要强调对质数取模？对合数取模的弊端是什么？
>
> 质数取模，可以最大化保证哈希值分布均匀。因为质数不与其他数字存在公约数，可以减少取模产生的周期性模式，从而避免哈希冲突。
>
> eg：如果选择 9 作为模数，可以被 3 整除，被 3 整除的 `key` 会被映射到 0，3，6 三个值
